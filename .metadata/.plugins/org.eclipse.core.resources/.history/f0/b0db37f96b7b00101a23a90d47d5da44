/*
 * timebase.cpp
 *
 *  Created on: Aug 16, 2025
 *      Author: ahmad
 */

#include "timebase.hpp"

#define CTRL_ENABLE 	(1U << 0)
#define CTRL_TICKINT 	(1U << 1)
#define CTRL_CLKSOURCE  (1U << 2)
#define CTRL_COUNTFLAG  (1U << 16)

#define MAX_DELAY	    0xFFFFFFFFU
#define ONE_SEC_DELAY	16000000
#define TICK_FREQ		1

volatile uint32_t TimeBase::msTicks = 0;

void TimeBase::init(){
	__disable_irq();
	SysTick->LOAD = ONE_SEC_DELAY - 1; // Load the SysTick timer with the value for 1 second
	SysTick->VAL = 0; // Clear the current value of the SysTick timer
	SysTick->CTRL = CTRL_CLKSOURCE | CTRL_TICKINT | CTRL_ENABLE; // Enable SysTick with processor clock, enable interrupt, and start the timer
	__enable_irq();
}

void TimeBase::delay(uint32_t delay){
	uint32_t start = getTicks(); // Get the current tick count
	uint32_t waitTicks = delay; // Set the number of ticks to wait

	if(waitTicks < MAX_DELAY){
		waitTicks+= TICK_FREQ; // Add one tick to ensure the delay is at least 1 ms
	}

	while((getTicks() - start) < waitTicks) {
		// Wait until the specified delay has passed
		// This loop will run until the difference between current ticks and start ticks is less than waitTicks
	}
}

uint32_t TimeBase::getTicks(){
	__disable_irq(); // Disable interrupts to ensure atomic access to msTicks
	uint32_t currentTicks = msTicks; // Read the current tick count
	__enable_irq(); // Re-enable interrupts after reading
	return currentTicks;
}

void TimeBase::tickIncrement(){
	msTicks += TICK_FREQ; // Increment the msTicks by the tick frequency
}
