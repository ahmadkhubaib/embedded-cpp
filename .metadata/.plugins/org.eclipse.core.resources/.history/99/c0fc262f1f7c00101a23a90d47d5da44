/*
 * adc.cpp
 *
 *  Created on: Aug 17, 2025
 *      Author: ahmad
 */


#include "adc.hpp"

#define GPIOAEN  	 (1U << 0) // Enable clock for GPIOA
#define ADC1EN 		 (1U << 8) // Enable clock for ADC1
#define ADC_CH1 	 (1U << 0) // Channel 1 for ADC
#define ADC_SEQ_LEN  0x00 // Sequence length for ADC
#define ADC_ON 		 (1U << 0) // ADC ON bit
#define ADC_CONT_CON (1U << 1) // Continuous conversion mode
#define ADC_SW_START (1U << 30) // Start software conversion
#define ADC_SR_EOC   (1U << 1) // End of conversion flag

ADC_OBJ::ADC_OBJ(ADC_Typedef* adcX, GPIO_Typedef* gpioX, uint8_t pin): adcX(adcX), gpio(gpioX), pin(pin){}

void ADC_OBJ::init()
{
	RCC->AHB1ENR |= GPIOAEN; // Enable clock for GPIOA
	gpioX->MODER |= (1U (2 * pin));
	gpioX->MODER |= (1U << (2 * pin + 1)); // Set pin as analog mode
	RCC->APB2ENR |= ADC1EN; // Enable clock for ADC1
	adcX->SQR3 = ADC_CH1; // Set channel 1 for ADC
	adcX->SQR1 = ADC_SEQ_LEN; // Set sequence length to 1
	adcX->CR2 |= ADC_ON; // Enable ADC
}

void ADC_OBJ::start_conversion()
{
	adcX->CR2 |= ADC_CONT_CON; // Set continuous conversion mode
	adcX->CR2 |= ADC_SW_START; // Start conversion
}

uint32_t ADC_OBJ::read()
{
	while (!(adcX->SR & ADC_SR_EOC)); // Wait until conversion is complete
	return adcX->DR; // Read the conversion result
}
